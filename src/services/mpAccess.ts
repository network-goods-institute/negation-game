import { db } from "@/services/db";
import { mpDocsTable } from "@/db/tables/mpDocsTable";
import { mpDocPermissionsTable } from "@/db/tables/mpDocPermissionsTable";
import { mpDocShareLinksTable } from "@/db/tables/mpDocShareLinksTable";
import { resolveSlugToId, isValidSlugOrId } from "@/utils/slugResolver";
import { and, eq, gt, isNull, or } from "drizzle-orm";
import { logger } from "@/lib/logger";

export type DocAccessRole = "owner" | "editor" | "viewer";

export type DocAccessResult =
  | {
    status: "ok";
    docId: string;
    ownerId: string | null;
    slug: string | null;
    role: DocAccessRole;
    source: "owner" | "permission" | "share" | "ownerless";
    shareLinkId?: string;
    requiresAuthForWrite?: boolean;
  }
  | { status: "not_found" }
  | { status: "forbidden"; requiresAuth?: boolean; docId?: string };

/**
 * Checks if a role has write permissions.
 * @param role - The role to check
 * @returns true if role is "owner" or "editor"
 */
export const canWriteRole = (role: DocAccessRole | null | undefined) =>
  role === "owner" || role === "editor";

/**
 * Checks if a user ID represents an anonymous user.
 * Anonymous users are identified by:
 * - null/undefined userId
 * - userId starting with "anon-" prefix (generated by getUserIdOrAnonymous)
 *
 * @param userId - The user ID to check
 * @returns true if the user is anonymous
 */
const isAnonymousId = (userId: string | null | undefined): boolean => {
  return !userId || userId.startsWith("anon-");
};

/**
 * Resolves document access for a user, checking permissions in priority order:
 * 1. Document owner (highest priority)
 * 2. Explicit user permissions (via mp_doc_permissions)
 * 3. Share link tokens (via mp_doc_share_links)
 *
 * For ownerless documents:
 * - Authenticated users can claim ownership
 * - Anonymous users get viewer access
 *
 * @param docId - Document ID or slug to resolve access for
 * @param opts - Options object
 * @param opts.userId - User ID to check access for (null for anonymous, "anon-" prefix for session)
 * @param opts.shareToken - Optional share link token (format: "sl-" + 16 chars)
 *
 * @returns DocAccessResult indicating access status and role:
 * - status: "ok" - Access granted with role and source
 * - status: "not_found" - Document doesn't exist
 * - status: "forbidden" - Access denied, may include requiresAuth flag
 *
 * @example
 * ```ts
 * // Check owner access
 * const access = await resolveDocAccess("doc-123", { userId: "user-456" });
 * if (access.status === "ok" && access.role === "owner") {
 *   // User is owner
 * }
 *
 * // Check share link access
 * const access = await resolveDocAccess("doc-123", {
 *   userId: "anon-xyz",
 *   shareToken: "sl-abc123..."
 * });
 * ```
 */
export const resolveDocAccess = async (
  docId: string,
  opts: { userId?: string | null; shareToken?: string | null }
): Promise<DocAccessResult> => {
  if (!isValidSlugOrId(docId)) return { status: "not_found" };

  const canonicalId = await resolveSlugToId(docId);
  const safeLimit = async (query: any) => {
    try {
      if (query && typeof query.limit === "function") {
        return (await query.limit(1)) || [];
      }
    } catch (error) {
      logger.error("[mpAccess] limit failed", error);
    }
    return [];
  };

  const docRow = await safeLimit(
    db
      .select({
        id: mpDocsTable.id,
        ownerId: mpDocsTable.ownerId,
        slug: mpDocsTable.slug,
      })
      .from(mpDocsTable)
      .where(eq(mpDocsTable.id, canonicalId))
  );

  const doc = docRow[0];
  if (!doc) return { status: "not_found" };

  const userId = opts.userId || null;
  const anonymous = isAnonymousId(userId);

  if (!doc.ownerId) {
    if (!anonymous) {
      return {
        status: "ok",
        docId: canonicalId,
        ownerId: null,
        slug: doc.slug || null,
        role: "owner",
        source: "ownerless",
      };
    }
    return {
      status: "ok",
      docId: canonicalId,
      ownerId: null,
      slug: doc.slug || null,
      role: "viewer",
      source: "ownerless",
      requiresAuthForWrite: true,
    };
  }

  if (userId && doc.ownerId && doc.ownerId === userId) {
    return {
      status: "ok",
      docId: canonicalId,
      ownerId: doc.ownerId,
      slug: doc.slug || null,
      role: "owner",
      source: "owner",
    };
  }

  if (userId) {
    const perms = await safeLimit(
      db
        .select({ role: mpDocPermissionsTable.role })
        .from(mpDocPermissionsTable)
        .where(
          and(
            eq(mpDocPermissionsTable.docId, canonicalId),
            eq(mpDocPermissionsTable.userId, userId)
          )
        )
    );
    if (perms[0]?.role) {
      return {
        status: "ok",
        docId: canonicalId,
        ownerId: doc.ownerId,
        slug: doc.slug || null,
        role: perms[0].role,
        source: "permission",
      };
    }
  }

  const shareToken = opts.shareToken || null;
  if (shareToken) {
    // Validate token format: must be "sl-" followed by 16 characters
    if (!shareToken.startsWith("sl-") || shareToken.length !== 19) {
      logger.warn(`[mpAccess] Invalid share token format: ${shareToken.substring(0, 5)}...`);
      return { status: "forbidden", docId: canonicalId, requiresAuth: true };
    }

    const now = new Date();
    const links = await safeLimit(
      db
        .select({
          id: mpDocShareLinksTable.id,
          role: mpDocShareLinksTable.role,
          requireLogin: mpDocShareLinksTable.requireLogin,
          token: mpDocShareLinksTable.token,
          expiresAt: mpDocShareLinksTable.expiresAt,
          disabledAt: mpDocShareLinksTable.disabledAt,
        })
        .from(mpDocShareLinksTable)
        .where(
          and(
            eq(mpDocShareLinksTable.docId, canonicalId),
            eq(mpDocShareLinksTable.token, shareToken),
            isNull(mpDocShareLinksTable.disabledAt),
            or(
              isNull(mpDocShareLinksTable.expiresAt),
              gt(mpDocShareLinksTable.expiresAt, now)
            )
          )
        )
    );

    const link = links[0];
    if (link) {
      if (link.requireLogin && anonymous) {
        return { status: "forbidden", requiresAuth: true, docId: canonicalId };
      }

      const role: DocAccessRole = link.role;

      return {
        status: "ok",
        docId: canonicalId,
        ownerId: doc.ownerId,
        slug: doc.slug || null,
        role,
        source: "share",
        shareLinkId: link.id,
        requiresAuthForWrite: false,
      };
    }
  }

  return { status: "forbidden", docId: canonicalId, requiresAuth: true };
};

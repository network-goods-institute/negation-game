[33mcommit 60dd6bdf860f714efe40e6b0b630dd51372c416d[m
Author: Bikatr7 <Bikatr7@proton.me>
Date:   Thu Sep 11 22:38:51 2025 +0900

    fixed masking logic for support edges

[1mdiff --git a/src/components/experiment/multiplayer/SupportEdge.tsx b/src/components/experiment/multiplayer/SupportEdge.tsx[m
[1mindex 5739adc..df12158 100644[m
[1m--- a/src/components/experiment/multiplayer/SupportEdge.tsx[m
[1m+++ b/src/components/experiment/multiplayer/SupportEdge.tsx[m
[36m@@ -1,31 +1,221 @@[m
[31m-import React from 'react';[m
[31m-import { StraightEdge, EdgeProps } from '@xyflow/react';[m
[32m+[m[32mimport React, { useEffect, useMemo } from "react";[m
[32m+[m[32mimport { StraightEdge, EdgeProps, getStraightPath } from "@xyflow/react";[m
[32m+[m[32mimport { EdgeLabelRenderer } from "@xyflow/react";[m
[32m+[m[32mimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";[m
[32m+[m[32mimport { useGraphActions } from "./GraphContext";[m
[32m+[m[32mimport { ContextMenu } from "./common/ContextMenu";[m
[32m+[m[32mimport { useEdgePerformanceOptimization } from "./common/useEdgePerformanceOptimization";[m
[32m+[m[32mimport { useAbsoluteNodePosition } from './common/useAbsoluteNodePosition';[m
 [m
 export const SupportEdge: React.FC<EdgeProps> = (props) => {[m
[31m-    const relevance = Math.max(1, Math.min(5, ((props as any).data?.relevance ?? 3)));[m
[32m+[m[32m    const { hoveredEdgeId, selectedEdgeId, setSelectedEdge, addObjectionForEdge, setHoveredEdge, updateEdgeAnchorPosition, deleteNode, updateEdgeRelevance, connectMode, beginConnectFromEdge, isConnectingFromNodeId, cancelConnect, completeConnectToEdge } = useGraphActions() as any;[m
[32m+[m[32m    const isHovered = hoveredEdgeId === props.id;[m
[32m+[m[32m    const [menuOpen, setMenuOpen] = React.useState(false);[m
[32m+[m[32m    const [menuPos, setMenuPos] = React.useState<{ x: number; y: number }>({ x: 0, y: 0 });[m
[32m+[m[32m    const { getRectPosition } = useAbsoluteNodePosition();[m
[32m+[m
[32m+[m[32m    const sourceX = (props as any).sourceX;[m
[32m+[m[32m    const sourceY = (props as any).sourceY;[m
[32m+[m[32m    const targetX = (props as any).targetX;[m
[32m+[m[32m    const targetY = (props as any).targetY;[m
[32m+[m
[32m+[m[32m    const { isHighFrequencyUpdates, sourceNode, targetNode, shouldRenderEllipses } = useEdgePerformanceOptimization({[m
[32m+[m[32m        sourceId: (props as any).source as string,[m
[32m+[m[32m        targetId: (props as any).target as string,[m
[32m+[m[32m        sourceX,[m
[32m+[m[32m        sourceY,[m
[32m+[m[32m        targetX,[m
[32m+[m[32m        targetY[m
[32m+[m[32m    });[m
[32m+[m
[32m+[m[32m    // Compute straight path[m
[32m+[m[32m    const [pathD, labelX, labelY] = useMemo(() => {[m
[32m+[m[32m        return getStraightPath({[m
[32m+[m[32m            sourceX: sourceX ?? 0,[m
[32m+[m[32m            sourceY: sourceY ?? 0,[m
[32m+[m[32m            targetX: targetX ?? 0,[m
[32m+[m[32m            targetY: targetY ?? 0,[m
[32m+[m[32m        });[m
[32m+[m[32m    }, [sourceX, sourceY, targetX, targetY]);[m
[32m+[m
[32m+[m[32m    const lastPosRef = React.useRef<{ x: number; y: number } | null>(null);[m
[32m+[m[32m    const rafRef = React.useRef<number>(0);[m
[32m+[m[32m    useEffect(() => {[m
[32m+[m[32m        if (!Number.isFinite(labelX) || !Number.isFinite(labelY)) return;[m
[32m+[m[32m        const last = lastPosRef.current;[m
[32m+[m[32m        if (last && Math.abs(last.x - labelX) < 0.5 && Math.abs(last.y - labelY) < 0.5) return;[m
[32m+[m
[32m+[m[32m        cancelAnimationFrame(rafRef.current);[m
[32m+[m[32m        rafRef.current = requestAnimationFrame(() => {[m
[32m+[m[32m            lastPosRef.current = { x: labelX, y: labelY };[m
[32m+[m[32m            updateEdgeAnchorPosition(props.id as string, labelX, labelY);[m
[32m+[m[32m        });[m
[32m+[m[32m        return () => cancelAnimationFrame(rafRef.current);[m
[32m+[m[32m    }, [labelX, labelY, props.id, updateEdgeAnchorPosition]);[m
[32m+[m
[32m+[m[32m    const edgeDataRelevance = (props as any).data?.relevance;[m
[32m+[m
[32m+[m[32m    const selected = useMemo(() => (selectedEdgeId || null) === (props.id as any), [selectedEdgeId, props.id]);[m
[32m+[m[32m    const relevance = useMemo(() => Math.max(1, Math.min(5, (edgeDataRelevance ?? 3))), [edgeDataRelevance]);[m
[32m+[m[32m    const edgeOpacity = useMemo(() => selected || isHovered ? 1 : Math.max(0.3, Math.min(1, relevance / 5)), [selected, isHovered, relevance]);[m
[32m+[m
[32m+[m[32m    const shouldRenderOverlay = useMemo([m
[32m+[m[32m        () =>[m
[32m+[m[32m            Number.isFinite(sourceX) &&[m
[32m+[m[32m            Number.isFinite(sourceY) &&[m
[32m+[m[32m            Number.isFinite(targetX) &&[m
[32m+[m[32m            Number.isFinite(targetY),[m
[32m+[m[32m        [sourceX, sourceY, targetX, targetY][m
[32m+[m[32m    );[m
[32m+[m[32m    const overlayStyle = useMemo(() => ({ pointerEvents: 'stroke' as const }), []);[m
[32m+[m
[32m+[m[32m    // Check connected nodes for masking[m
[32m+[m[32m    const srcHasFavor = (sourceNode as any)?.type === 'point' || (sourceNode as any)?.type === 'objection';[m
[32m+[m[32m    const tgtHasFavor = (targetNode as any)?.type === 'point' || (targetNode as any)?.type === 'objection';[m
[32m+[m[32m    const srcFavor = Math.max(1, Math.min(5, (sourceNode as any)?.data?.favor ?? 5));[m
[32m+[m[32m    const tgtFavor = Math.max(1, Math.min(5, (targetNode as any)?.data?.favor ?? 5));[m
[32m+[m[32m    const srcIsTitle = (sourceNode as any)?.type === 'title';[m
[32m+[m[32m    const tgtIsTitle = (targetNode as any)?.type === 'title';[m
[32m+[m[32m    const srcLowOpacity = (srcHasFavor && srcFavor <= 3) || srcIsTitle;[m
[32m+[m[32m    const tgtLowOpacity = (tgtHasFavor && tgtFavor <= 3) || tgtIsTitle;[m
[32m+[m
     return ([m
[31m-        <StraightEdge[m
[31m-            {...props}[m
[31m-            style={{[m
[31m-                stroke: '#9CA3AF',[m
[31m-                strokeWidth: Math.max(1, Math.min(8, relevance * 1.4)),[m
[31m-                strokeDasharray: '6,6',[m
[31m-            }}[m
[31m-            interactionWidth={24}[m
[31m-            label="+"[m
[31m-            labelShowBg={false}[m
[31m-            labelStyle={{[m
[31m-                padding: 0,[m
[31m-                width: 20,[m
[31m-                height: 20,[m
[31m-                stroke: 'white',[m
[31m-                strokeWidth: 2,[m
[31m-                fontSize: 28,[m
[31m-                fontWeight: 700,[m
[31m-                fill: '#4B5563',[m
[31m-                userSelect: 'none',[m
[31m-            }}[m
[31m-        />[m
[32m+[m[32m        <>[m
[32m+[m[32m            {/* Edge elements with opacity and node masking */}[m
[32m+[m[32m            <g style={{ opacity: edgeOpacity }}>[m
[32m+[m[32m                <defs>[m
[32m+[m[32m                    <mask id={`support-mask-${props.id}`}>[m
[32m+[m[32m                        <rect x="-10000" y="-10000" width="20000" height="20000" fill="white" />[m
[32m+[m[32m                        {shouldRenderEllipses && srcLowOpacity && (() => {[m
[32m+[m[32m                            const rectPos = getRectPosition(sourceNode, true);[m
[32m+[m[32m                            return rectPos ? ([m
[32m+[m[32m                                <rect x={rectPos.x} y={rectPos.y} width={rectPos.width} height={rectPos.height} fill="black" />[m
[32m+[m[32m                            ) : null;[m
[32m+[m[32m                        })()}[m
[32m+[m[32m                        {shouldRenderEllipses && tgtLowOpacity && (() => {[m
[32m+[m[32m                            const rectPos = getRectPosition(targetNode, true);[m
[32m+[m[32m                            return rectPos ? ([m
[32m+[m[32m                                <rect x={rectPos.x} y={rectPos.y} width={rectPos.width} height={rectPos.height} fill="black" />[m
[32m+[m[32m                            ) : null;[m
[32m+[m[32m                        })()}[m
[32m+[m[32m                    </mask>[m
[32m+[m[32m                </defs>[m
[32m+[m[32m                <g mask={`url(#support-mask-${props.id})`}>[m
[32m+[m[32m                    {/* Selection highlight following straight line */}[m
[32m+[m[32m                    {useMemo(() => Number.isFinite(sourceX) && Number.isFinite(sourceY) && Number.isFinite(targetX) && Number.isFinite(targetY) && selected, [sourceX, sourceY, targetX, targetY, selected]) && ([m
[32m+[m[32m                        <path d={pathD} stroke="#000" strokeWidth={8} fill="none" strokeLinecap="round" opacity={0.85} />[m
[32m+[m[32m                    )}[m
[32m+[m[32m                    <StraightEdge[m
[32m+[m[32m                        {...props}[m
[32m+[m[32m                        style={useMemo(() => ({[m
[32m+[m[32m                            stroke: '#9CA3AF',[m
[32m+[m[32m                            strokeWidth: Math.max(1, Math.min(8, relevance * 1.4)),[m
[32m+[m[32m                            strokeDasharray: '6,6',[m
[32m+[m[32m                        }), [relevance])}[m
[32m+[m[32m                        interactionWidth={24}[m
[32m+[m[32m                        label="+"[m
[32m+[m[32m                        labelShowBg={false}[m
[32m+[m[32m                        labelStyle={{[m
[32m+[m[32m                            padding: 0,[m
[32m+[m[32m                            width: 20,[m
[32m+[m[32m                            height: 20,[m
[32m+[m[32m                            stroke: 'white',[m
[32m+[m[32m                            strokeWidth: 2,[m
[32m+[m[32m                            fontSize: 28,[m
[32m+[m[32m                            fontWeight: 700,[m
[32m+[m[32m                            fill: '#4B5563',[m
[32m+[m[32m                            userSelect: 'none',[m
[32m+[m[32m                        }}[m
[32m+[m[32m                    />[m
[32m+[m[32m                </g>[m
[32m+[m[32m            </g>[m
[32m+[m[32m            {/* Invisible interaction overlay along the whole line (on top) */}[m
[32m+[m[32m            {shouldRenderOverlay && ([m
[32m+[m[32m                <path[m
[32m+[m[32m                    d={pathD}[m
[32m+[m[32m                    stroke="rgba(0,0,0,0)"[m
[32m+[m[32m                    strokeWidth={36}[m
[32m+[m[32m                    strokeLinecap="round"[m
[32m+[m[32m                    strokeLinejoin="round"[m
[32m+[m[32m                    fill="none"[m
[32m+[m[32m                    style={overlayStyle}[m
[32m+[m[32m                    onClick={(e) => { e.stopPropagation(); setSelectedEdge?.(props.id as string); }}[m
[32m+[m[32m                    onMouseDown={(e) => { if (connectMode) { e.preventDefault(); e.stopPropagation(); beginConnectFromEdge?.(props.id as string); } }}[m
[32m+[m[32m                    onMouseUp={(e) => { if (connectMode) { e.preventDefault(); e.stopPropagation(); completeConnectToEdge?.(props.id as string, labelX, labelY); } }}[m
[32m+[m[32m                    onContextMenu={(e) => { e.preventDefault(); e.stopPropagation(); setSelectedEdge?.(props.id as string); setMenuPos({ x: e.clientX, y: e.clientY }); setMenuOpen(true); }}[m
[32m+[m[32m                />[m
[32m+[m[32m            )}[m
[32m+[m[32m            {/* Midpoint control (match negation style, but gray for support) */}[m
[32m+[m[32m            <foreignObject[m
[32m+[m[32m                x={useMemo(() => (labelX || 0) - 8, [labelX])}[m
[32m+[m[32m                y={useMemo(() => (labelY || 0) - 8, [labelY])}[m
[32m+[m[32m                width={16}[m
[32m+[m[32m                height={16}[m
[32m+[m[32m                style={useMemo(() => ({ pointerEvents: 'all' }), [])}[m
[32m+[m[32m            >[m
[32m+[m[32m                <div[m
[32m+[m[32m                    onContextMenu={(e) => { e.preventDefault(); e.stopPropagation(); setSelectedEdge?.(props.id as string); setMenuPos({ x: e.clientX, y: e.clientY }); setMenuOpen(true); }}[m
[32m+[m[32m                    title="Edge controls"[m
[32m+[m[32m                    className="w-4 h-4 rounded-full bg-white border flex items-center justify-center select-none"[m
[32m+[m[32m                    style={{ borderColor: '#9CA3AF', cursor: 'pointer', userSelect: 'none' as any }}[m
[32m+[m[32m                    draggable={false}[m
[32m+[m[32m                >[m
[32m+[m[32m                    <div className="w-1 h-1 rounded-full" style={{ backgroundColor: '#9CA3AF' }} />[m
[32m+[m[32m                </div>[m
[32m+[m[32m            </foreignObject>[m
[32m+[m[32m            {[m
[32m+[m[32m                /* Always render overlay; show stars only when simulation is on */[m
[32m+[m[32m                ([m
[32m+[m[32m                    <EdgeLabelRenderer>[m
[32m+[m[32m                        <div[m
[32m+[m[32m                            style={useMemo(() => ({[m
[32m+[m[32m                                position: 'absolute',[m
[32m+[m[32m                                transform: `translate(-50%, -50%) translate(${labelX}px, ${labelY + 18}px)`,[m
[32m+[m[32m                                zIndex: 1000,[m
[32m+[m[32m                                pointerEvents: 'all'[m
[32m+[m[32m                            }), [labelX, labelY])}[m
[32m+[m[32m                            onMouseEnter={() => setHoveredEdge(props.id as string)}[m
[32m+[m[32m                            onMouseLeave={() => setHoveredEdge(null)}[m
[32m+[m[32m                            className={`transition-opacity duration-300 ${isHovered ? 'opacity-100' : 'opacity-0'}`}[m
[32m+[m[32m                        >[m
[32m+[m[32m                            <div className="flex items-center justify-center gap-2 bg-white/95 backdrop-blur-sm border rounded-md shadow px-2 py-1">[m
[32m+[m[32m                                <div className="flex items-center gap-2 text-[11px] select-none">[m
[32m+[m[32m                                    <span className="uppercase tracking-wide text-stone-500">Relevance</span>[m
[32m+[m[32m                                    <TooltipProvider>[m
[32m+[m[32m                                        <div className="flex items-center gap-1">[m
[32m+[m[32m                                            {[1, 2, 3, 4, 5].map((i) => ([m
[32m+[m[32m                                                <Tooltip key={`rel-${i}`}>[m
[32m+[m[32m                                                    <TooltipTrigger asChild>[m
[32m+[m[32m                                                        <button title={`Set relevance to ${i}`} onMouseDown={(e) => e.preventDefault()} onClick={(e) => { e.stopPropagation(); updateEdgeRelevance?.(props.id as string, i as any); }}>[m
[32m+[m[32m                                                            <span className={i <= ((props as any).data?.relevance ?? 3) ? 'text-gray-600' : 'text-stone-300'}>★</span>[m
[32m+[m[32m                                                        </button>[m
[32m+[m[32m                                                    </TooltipTrigger>[m
[32m+[m[32m                                                    <TooltipContent side="top" className="text-xs">Relevance: {i}/5</TooltipContent>[m
[32m+[m[32m                                                </Tooltip>[m
[32m+[m[32m                                            ))}[m
[32m+[m[32m                                        </div>[m
[32m+[m[32m                                    </TooltipProvider>[m
[32m+[m[32m                                </div>[m
[32m+[m[32m                                <button[m
[32m+[m[32m                                    onMouseDown={(e) => e.preventDefault()}[m
[32m+[m[32m                                    onClick={(e) => { e.stopPropagation(); addO